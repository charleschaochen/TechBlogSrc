title: JVM内存区域与对象探秘
date: 2014-06-28 17:44:33.0
tags:
- Java虚拟机
- 运行时数据区
categories:
- Java虚拟机

---

JVM运行时数据区Java虚拟机具有自动内存管理机制，对于Java程序猿来说，可以省去很多内存管理的工作量，Java程序也不容易出现内存泄漏和内存溢出的问题。然而，一旦出现内存泄漏或溢出等问题，如果不了解虚拟机是怎样使用内存，分析和排查错误将成为一项非常艰难的工作。Java虚拟机在程序运行过程中会将管理的内存划分为若干个不同的区域，Java虚拟机所管理的内存包括以下几个运行时数据区：1. 程序计数...

<!-- more -->

#### **JVM运行时数据区** ####

Java虚拟机具有自动内存管理机制，对于Java程序猿来说，可以省去很多内存管理的工作量，Java程序也不容易出现内存泄漏和内存溢出的问题。然而，一旦出现内存泄漏或溢出等问题，如果不了解虚拟机是怎样使用内存，分析和排查错误将成为一项非常艰难的工作。

Java虚拟机在程序运行过程中会将管理的内存划分为若干个不同的区域，Java虚拟机所管理的内存包括以下几个运行时数据区：

![Image 1][]

1. 程序计数器

（1） 程序计数器用来保存下一条执行的字节码指令的地址，程序中的分支、循环、线程恢复等等都需要依靠程序计数器去实现。

（2） 程序计数器是线程私有的，每一个线程都维护自己的程序计数器。我们知道多线程是通过线程轮流切换分配CPU时间片实现的，当一个线程获取CPU执行时间时，需要依靠程序计数器保存的值，保证切换后能恢复到上次执行的位置继续执行。

（3） 程序器是一块较小的内存空间，JVM中唯一不会发生OutOfMemoryError异常的内存区域。

  


2. 虚拟机栈

（1） Java程序中每个方法的调用都会在虚拟机栈中分配栈帧空间，用来存储方法操作数、局部变量表、方法出口等信息。Java方法从开始调用到执行结束就对应虚拟机栈中栈帧从入栈到出栈的过程。

（2） 虚拟机栈中有个重要的区域称为局部变量表，局部变量表存放编译器可知的各种基本数据类型的变量。局部变量表的大小在编译器已经完全确定，程序运行过程中不会改变。

（3） 虚拟机栈是线程私有的，每个线程都维护自己的栈空间。

（4） 当Java方法申请的栈深度大于虚拟机栈允许的深度时，会抛出StackOverflowError异常，例如递归方法的深度太深时，很容易就发生栈溢出。现在很多JVM都允许动态扩展栈空间，即在栈空间不足时，可以动态申请内存，但如果动态扩展时无法申请到足够内存，也会跑出OutOfMemoryError异常。

  


3. 本地方法栈

（1） 所谓的本地方法（Native Method）指的是使用其他非Java语言（例如C/C++）实现的方法，可供Java程序调用，目的是解决一些Java语言无法或很难解决的问题。本地方法栈的功能与虚拟机栈基本一样，只不过虚拟机栈是服务于Java方法字节码，而本地方法栈是服务于本地方法。很多JVM，例如主流的HotSpot虚拟机，将虚拟机栈与本地房发展合二为一。

（2） 本地方法栈同样是线程私有的。

  


4. Java堆

（1） Java堆是JVM所管理的内存中最大的一块，Java程序中几乎所有的对象实例都在堆中分配内存空间。Java堆也是垃圾回收器的主要工作区域。

（2） Java堆是线程共享的数据区，该区域随虚拟机的启动而创建。

（3） 当Java堆没有足够内存为对象分配空间时，会抛出OutMemoryError异常。

  


5. 方法区

（1） 方法区存放已被类加载器加载的类信息、JIT即时编译器编译后的字节码、程序中的常量、静态变量等数据。

（2） 方法区是所有线程共享的数据区。

（3） 垃圾回收器在方法区进行垃圾回收工作比较少见，主要是对常量池的回收或一些已加载的类的卸载。

（4） 当方法区无法满足内存分配的需求时，也会抛出OutOfMemoryError异常

（5） 方法区中有一块重要的区域成为运行时常量池（Runtime Constant Pool），当类被加载后，类中的字面直接量（如字符串、整型数、浮点数等）和符号引号会被存入到常量池中。运行时常量池具有动态性，也就是说在程序运行时，也有可能有新的常量存入到常量池中，例如调用String对象的intern方法时，当字符串对象所代表的字符没有在常量池中出现过时，该字符串会被存入到常量池中。

关于intern方法：当字符串对象调用intern方法时，首先会在常量池中查找是否存在该字符串，若存在，则返回常量池中该字符串的地址引用，若不存在，则会将字符串存入常量池中，并使用原字符串对象的引用指向它。（JDK6或6以前的版本，当字符串不存在常量池中时，会复制一个字符串实例到常量池，返回新实例的引用）

例如以下程序：

    String a = "he" ;
    String b = "llo";
    String c = a + b;
    System. out.println(c.intern() == c); // true，JDK6下为false

如果在调用intern方法之前，又定义了String d= "hello"; 那么当执行intern方法时，"hello"已经存在于常量池中，且引用为d，因此c.intern()返回的是d，结果是false。

####     ####

#### 对象的创建、内存布局与访问定位 ####

#### 1. 对象的创建 ####

当虚拟机遇到new关键字指令之后，创建对象的步骤如下：

（1） 检查new之后的类符号是否能在常量池中找到对应的符号引用，且该符号引用所代表的类是否已经被类加载器加载、解析过，如果没有就需要先执行加载的过程

（2） 为对象实例分配内存，由于对象的小大在类加载后就可以完全确定，所以为实例分配内存相当于在Java堆中划分出一块确定大小的内存空间。Java堆的内存分配方式有两种：

 *  若Java堆中的内存足够规整，即已使用的内存和空闲的内存严格划分开来，中间使用一个指令作为临界，那么分配内存时只需要将指针往空间内存方向移动与实例大小等同的距离，这种分配方式称为指针碰撞。

指针碰撞方式并不是线程安全的，例如线程A中的实例已经在堆中分配了内存，还没来得急移动指针，此时线程B同时也在利用该指针分配内存，就会导致线程A的实例与线程B的实例分配到重叠的内存。解决方法有两种：一是对分配内存的动作进行加锁，另一种是使用线程本地分配缓存（TLAB，Thread Local Allocation Buffer），即线程启动时预先向Java堆申请一块内存作为缓存，线程中创建的实例在这块缓存中分配内存，当缓存需要扩展时，才进行同步加锁。可以通过-XX:+/-UseTLAB参数设置JVM使用线程本地分配缓存。

 *  若Java堆中的内存不规整，即已使用的内存与未使用的内存相互交错，此时需要维护一张空闲表记录所有空闲内存块的位置，分配内存时从表中查找一块足够大小的空闲块进行分配，分配完成后更新空闲表。这种方式称为空闲表法。

  


Java堆的内存是否规整其实是由垃圾回收器是否具有压缩整理的功能决定的，如果垃圾回收器在回收对象实例后，对Java堆的空间进行压缩整理，就可以保证Java堆的内存规整。

（3） 初始化内存，将对象实例分配到的内存初始化为零值，从而保证对象实例的字段可以在不赋初值的情况下直接使用

（4） 设置对象头，设置对象的类型指针、运行时数据等

（5） 调用对象的构造方法进行初始化

  


2. 对象的内存布局

对象所分配到的内存划分为三个部分：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）

（1） 对象头

对象头数据包括两部分信息：对象运行时数据和类型指针。

 *  对象运行时数据，例如对象哈希码、GC分代年龄、锁状态标识、锁指针、偏向线程ID、偏向时间戳等等。这部分数据的长度在32位操作系统下为32bit，64位操作系统下为64bit。为节省空间，对象头并不会存储全部的运行时数据，而是根据锁状态标识的不同而选择性存储运行时数据，例如当锁状态标识为未锁定时，对象头存放哈希码和GC分代年龄。
 *  类型指针，指向保存在方法区中的该对象所属的类型信息，虚拟机通过对象的类型指针确定对象所属的类型。

  


（2） 实例数据这部分数据存储对象定义的各种类型的字段内容

（3） 对齐填充

这部分数据并无实际意义，仅仅起到占位符的作用。Hotspot虚拟机规定对象内存的起始地址必须是8字节的整数倍，如果对象的对象头和实例数据部分加起来没有8字节的整数倍时，就需要通过对齐填充来补齐。

  


3. 对象的访问定位

当使用对象时，我们需要先定位对象的具体地址，这个过程时通过虚拟机栈上的Reference数据来查找定位保存在Java堆中的实例数据以及保存在方法区中的类型信息。具体的访问定位方式有两种：

（1） 句柄定位访问方式。即在Java堆中划分出一块区域作为句柄池，每个对象实例在句柄池中维护两个引用，一个引用指向堆中实例数据的地址，另一个引用指向方法区中所属类型的信息。这种方式下，栈中的reference数据存放的是句柄池中的实例数据地址。

![Image 1][]

（2） 直接定位访问方式。这种方式下，栈中的reference数据存放的直接就是堆中对象的内存地址，由对象内存中的类型指针可以找到方法区中的类型信息。

![Image 1][]

两种访问方式各有优劣。使用句柄访问方式，当对象被移动时（垃圾回收时经常需要移动对象），不需要更新reference引用，只需要更新句柄池中该对象的实例数据指针即可，但这种方式需要两次指针定位才能访问到对象实例数据。而使用直接访问方式，只需要一次指针定位就可以访问到实例数据，但当对象被移动时，需要去更新栈中的reference数据。


[Image 1]: 